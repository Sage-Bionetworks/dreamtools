#!/ebi/research/software/Linux_x86_64/opt/stow/python-2.7.1-shared/bin/python -u
#
#  Copyright 2011 EBI
#
#  File author(s): Thomas Cokelaer <cokelaer@ebi.ac.uk>
#
# Based on TF_web.pl (perl version) provided by Rachel Norel (Columbia University)

#$Id: TF_web.pl.py 2303 2012-09-03 14:23:50Z cokelaer $

import cgitb
import zipfile
import tempfile
import os
from os.path import join as pj
import sys
import subprocess
import threading
import time

import pandas as pd


# if dev change url, R_LIBS_SITE, path
params = {
#    'url':'http://wwwdev.ebi.ac.uk/%s/%s/' %(server, directory),
    'R_LIBS_SITE':'/net/isilon4/research/enright/wwwdev/dream/RPackages',
    'path':'/net/isilon4/research/enright/wwwdev/dream/',
    'R':'/ebi/research/software/Linux_x86_64/bin/R-2.13.0',
#    'cgibin_path':'/%s/%s/cgi-bin/'%(server,directory),
    'this_script' :'TF_web.pl',
    'img_width':'400px', 
    'img_height':'400px',
    'iframe_height':'450px',
    'maxtime': 220, # due to server config file, we have to set a maxtime 220 seems to be enough
    }



# Nothing to changed here below #####################################

#cgitb.enable() # to allow tracking exception in the HTML page.
 


class MyException(Exception):
    """Simple Exception class that prints a message with HTML syntax."""
    def __init__(self, value):
        self.value = value
        print(self)

    def __str__(self):
        msg = """<p style="background-color:#FF6633;padding:1em;margin:2em;">An error occurred: %s<br>""" % self.value
        thislink = pj(params['url'], 'cgi-bin', params['this_script'])
        msg += """Please reload the page <a href="%s">reload</a></p>""" % thislink
        return msg




class D5C2(object):
    """A class dedicated to running the different processing steps on 
    the data provided by the user.
    """
    def __init__(self, prediction_file, tmpdir='test'):
        self.tmpdir = tmpdir               # directory where to save the results
        self.logfile = "status.html"       # where to store the log file
        self.prediction_file = "pred.txt"  # where to store the prediction file 
        self._fid = None                   # fid to self.logfile used to dynamically save the log
        self.image_filename = "final.png"  # stores the image generated by R script
        self.cwd = None
        self.prediction_file = prediction_file


        self._init = False
        self.init()


        print('Loading the gold standard and user prediction. Takes a few seconds')
        self.load_gs()
        self.uploading()

    def error(self, msg="unknwon error"):
        """If an error is known, use this function to raise it"""
        # close the log file (status.html)
        self.close()
        raise MyException(msg)

    def log(self, msg):
        """Something to tell to the user? Use this function. It will write
        the message argument into the log file."""
        self._fid.write(msg+"\n")
        self._fid.flush()

    def init(self):
        """Creates the temporary directory and the sub directories.

        Behaviour differs whether the directory was provided
        in the constructor or not.
        """
        self.cwd = os.path.abspath(os.path.curdir)

        if self.tmpdir == None:
            self.tmpdir = tempfile.mkdtemp(dir="../tmp")
            #os.system("chmod 755 %s" % self.tmpdir)
            #os.system("chmod 766 %s/status.html" % self.tmpdir)
            try:
                os.mkdir(pj(self.tmpdir, "Data"))
                os.mkdir(pj(self.tmpdir, "Out"))
                os.mkdir(pj(self.tmpdir, "DV"))
                os.mkdir(pj(self.tmpdir, "Probes"))
            except:
                self.error("Could not create directories")
            self.logfile = pj(self.tmpdir, self.logfile)
            self._fid = open(self.logfile, "w+")
            #self.log("Data will be stored in %s<br>" % self.tmpdir)
        else:# already built, so note the w+ changed to a+ and no title
            #os.system("chmod 766 %s/status.html" % self.tmpdir)
            if not os.path.isdir(self.tmpdir):
                self.error("The temporary directory provided does not seem to exist(%s)" % self.tmpdir)
            #os.system("chmod 755 %s" % self.tmpdir)
            self.logfile = pj(self.tmpdir, self.logfile)
            self._fid = open(self.logfile, "w+")
            self.log("Data will be stored in %s<br>" % self.tmpdir)

#
        self.image_filename = pj(self.tmpdir, "results", self.image_filename)
        self._init = True


    def load_gs(self, answer='Data/Answers.txt'):
        df = pd.read_csv(answer, sep='\t')
        self.gs = df

    def split_data(self, precision=6):
        """precision is to get same results as in the original perl script"""
        mask = self.gs.Flag == 0
        self.user_data_clean = self.user_data[mask].copy()
        print('Removing flagged data (%s out of %s)' % (self.gs.shape[0] - mask.sum(), self.gs.shape[0]))
        self.gs_clean = self.gs[mask].copy()
        # local aliases
        gs = self.gs_clean
        user_data = self.user_data_clean

        from easydev import progress_bar
        pb = progress_bar(66, interval=1)
        for transcription in range(1,67):
            this_tf = 'TF_%s'  % transcription
            tf_gs = gs[gs.Id == this_tf].Answer
            tf_user = user_data[user_data.TF_Id == this_tf].Signal_Mean
            df = pd.concat([tf_gs, tf_user], axis=1)
            df.to_csv(this_tf + 'tmp.dat', index=False, sep='\t', header=False, float_format="%f")

            pb.animate(transcription)

    def uploading(self):
        """Get the file from the form, save it, decompress it."""
        # TODO: replace TF_Id with same name as in GS
        import zipfile
        z = zipfile.ZipFile(self.prediction_file)
        assert len(z.filelist) == 1, "zipped archive should contain only 1 file"

        # extract in byte
        data = z.read(z.filelist[0])

        #print("saving locally")
        #fh = open('tmp_' + z.filelist[0].filename, 'w')
        #fh.write(data)
        #fh.close()

        self.prediction_file_unzipped = 'tmp_' + z.filelist[0].filename
        import StringIO
        df = pd.read_csv(StringIO.StringIO(data), sep='\t');# engine='python')

        self.user_data = df



    def validating(self):
        self.log("<strong>Validating the data</strong></br>   Please wait...")
        cwd = os.path.abspath(os.path.curdir)
        proc = subprocess.Popen(
                ["perl", "%s/DREAM5_challenge2_Validate.pl"%cwd, "%s" % self.prediction_file_unzipped],
                        stderr=subprocess.PIPE, stdout=subprocess.PIPE)
        error = proc.stderr.read()
        if len(error)>0:
            self.error("Validation failed with this error:" + error)
        self.log("done</p>" )


    def probe_data_preprocessing1(self):
        # mkdir Probes
        try: os.mkdir('Probes')
        except: pass

        # reads probes (sequences)
        print('Reading probes')
        # just one column so no need for a separator
        probes = pd.read_csv('Data/probes35.txt')

        # GOOD AND CHECKED
        print('Creating val.txt')
        # create the val.txt (first and third column of pred.txt)
        df = self.user_data[['TF_Id', 'Signal_Mean']].copy()
        df['Signal_Mean'] = df['Signal_Mean'].map(lambda x: round(x,6))
        #df.to_csv('val.csv', sep='\t', index=False, float_format="%.6f")

        # data.txt is paste of probes35.txt and val.txt
        data = pd.concat([probes, df], axis=1)

        # Creates probes/TF_1.dat that contains the sequence from the GS and the answer from the user
        # for each TF
        # GOOD AND CHECKED
        print('Creating probes/TF_1_tmp.csv + sorting ')
        from easydev import progress_bar
        pb = progress_bar(67, interval=1)
        for i in range(1,67):
            # could use a groupby here ? faster  maybe
            tag = 'TF_%s' % i
            sequence = data[['Sequence']].ix[self.gs.Id==tag]
            answer = data.Signal_Mean[data.TF_Id == tag]
            df = pd.concat([sequence, answer], axis=1)
            df.sort(columns=['Signal_Mean', 'Sequence'], ascending=[False, False], inplace=True)
            df['Signal_Mean'] = df['Signal_Mean'].map(lambda x: round(x,6))
            df.to_csv('Probes/%s_tmp.csv' % tag, sep='\t', index=False, header=False,
                      float_format="%.6f")
            pb.animate(i)

    def read_octomers(self):
        self.octomers_gs = pd.read_csv('Data/8mers_gs.txt', sep='\t', header=None)

        self.octomers = pd.read_csv('Data/all_8mers.txt', sep='\t', header=None)  # contains reverse complemtn
        self.octomers.columns = ['octomer','octomerRC']

        # build a dictionary out of it /

        self.probes_gs = pd.read_csv('Data/probe35_gs.txt', header=None)

    def probe_data_processing(self):
        #
        """

     my $fileDVP = $WRK_DIR.'/DVP/TF_'.$i.'.dat';
     my $fileO = $WRK_DIR.'/Out/TF_'.$i.'.dat';
     my $fileDV = $WRK_DIR.'/DV/TF_'.$i.'.dat';
     #
     open(OUT,"> $fileO") || die "Can't open file $fileO";
     my %ids = ();
     open(IN,$file) || die "Can't open file $file (why? $!)";
     while(<IN>) #Matt's code in this loop, but I added the calculation of median and the reverse complement
     {
        chomp;
        @tabs = split (/\t/);
        $seq = shift (@tabs);
        @seq = split (//, $seq);
        $score = shift (@tabs);
        chomp $score;
        for (my $i=0; $i<scalar @seq-$len+1; $i++) {
            $cur = substr ($seq, $i, $len);
7            if (exists $u8mers{$cur}) {$curR = $cur;}
8            else {$curR = $u8mersRC{$cur};} ##real current is from the list of 8mers, if not there take RC
9            if (exists $ids{$curR}) {$ids{$curR} .= $score."\t";}
            else {$ids{$curR} = $score."\t";}
 #           #print OUT "$cur\t$score\n";
        }
     }
154     close IN;

        :return:
        """
        self.read_octomers()


        octomers = self.octomers.octomer
        octomersRC = self.octomers.octomerRC
        mapping1  = dict([(k,v) for k,v in zip(octomers.values, octomersRC.values)])
        mapping2  = dict([(k,v) for k,v in zip(octomersRC.values, octomers.values)])


        import collections
        from easydev import progress_bar
        pb = progress_bar(67, interval=1)
        for tf_index in range(1,67):
            tf = pd.read_csv("Probes/TF_%s_tmp.csv" %tf_index, sep="\t",
                             header=None)
            tf.columns = ['Sequence', 'Score']
            ids = collections.defaultdict(list)
            for index, row in tf.iterrows():
                seq, score = row
                # scan the sequence
                for i in range(0, len(seq)-8+1):
                    subseq = seq[i:i+8]
                    try:
                        mapping1[subseq]
                        curR = subseq
                    except:
                        curR = mapping2[subseq]
                    ids[curR].append(score)
            # now let us build the new dataframe for the indices found
            import numpy as np
            df = pd.DataFrame({0:[k for k in  ids.keys()],
                               1:[np.median(v) for v in ids.values()]})
            df.sort(columns=1, ascending=False, inplace=True)
            df.to_csv('Out/TF_%s_tmp.dat' % tf_index, index=False)
            pb.animate(tf_index)


            self.ids = ids
            break







    def probe_data(self, ROnly):
        """Launch the probe_to_mersFULL.pl script and tf.r script 

        Since this part is long to run (about 4-5 minutes), the output is really
        dependent on the server configuration. This function ideally should be written
        in a very simple manner. However, because of the current configuration server, the 
        timeout is less than the duration of this script. Therefore, trick had to be found. 

        This is done by running the script in the background, writting the status in a frame
        that is refreshed.

        The R command must be after the probe is over.

        :param ROnly: to run only the R script

        
        """
        self.read_octomers()
        self.probe_data_preprocessing1()
        self.probe_data_processing()

        self.log("<p><strong>Probing data</strong>    Please wait<br>")
        cgidir = os.path.abspath(os.path.curdir)
        t1 = time.time()
        if ROnly ==True:
            cmd = """%s""" % self.getRcmd()
        else:
            cmd = """perl %s/probe_to_8mersFULL.pl %s %s ; %s""" % (cgidir, pj(cgidir, '..', 'Data'), pj(cgidir, self.tmpdir), self.getRcmd())
        proc = subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)

        # even though the computation is not over (proc.poll()) it stops if 
        # maxtime is reached. maxtime is set according to the timeout of the
        # server than is 300 seconds.
        mytime = 0
        maxtime = params['maxtime'] 
        self.log("   completed:<br>" )
        while mytime < maxtime and proc.poll()==None:
            mytime = mytime + 20
            for i in range(0, 20):
                time.sleep(1)
                self.log(".") # just to send information
            try:
                files = os.listdir(pj(self.tmpdir, "Out"))
                max_processed = max([float(f[3:5]) for f in files])
            except:
                max_processed = 0.
            self.log("             %10.3s %%<br>" % ((max_processed/66.*100) ))
        #output = proc.stdout.read()
        #error = proc.stderr.read()
        #self.log("AAA:" + output[-1] + "AAA<br>") 
        print "<br>"
        #self.log(output)

        t2 = time.time()
        self.log("Probing took %10.4s" % str(t2-t1))
        self.log("done</p>")
        self.log("<p><strong>Running R script in the background.</strong></p> ")
        
        return proc

    def getRcmd(self):
        cwd = os.path.abspath(os.path.curdir)
        cmd = "export R_LIBS_SITE=%s ; %s --vanilla < %s/tf.r %s > %s/Routput.out" % (params['R_LIBS_SITE'], params['R'], cwd, pj(cwd, self.tmpdir), pj(cwd, self.tmpdir))
        cmd += "; mv %s %s" % (pj(cwd, self.tmpdir, "final.png"), pj(cwd, self.tmpdir, "results"))
        return cmd 


class HTMLBase(object):
    """An ABC class used by BadCaptach and BuildHTMLPage"""

    def __init__(self):
        self.main_title = "TF-DNA Motif Recognition"
        self.footer = "</body>\n</html>"
        self.titles = "<h1>%s Challenge (D5C2)</h1><h2>Prediction Evaluation</h2>" % self.main_title

    def print_title(self):
        print self.titles

    def print_end(self):
        print "</body>"
        print "</html>"

    def print_header(self, mode="norefresh", location=None):
        print """Content-type:text/html\r""" # note the double \n (compulsary)
        print "\n\n"
        print self.header % self.tmpdir
        print """<body background="../pbm2.gif">"""



class BuildHTMLPage(HTMLBase):
    def __init__(self, directory=None):
        super(BuildHTMLPage, self).__init__()
        if directory == None:
            raise MyException("A valid directory must be provided.")
        self.tmpdir = directory

        # note that the blank line is required for the content to be interpreted
        self.header = """
         <html>
         <head>
         <title>%s</title>
         <script language="JavaScript" type="text/javascript">
             function refresh_frame() 
             { 
                 document.getElementById('myframe').src="%s/status.html";;
                 setTimeout("refresh_frame()", 5000);
                 
             } 
         </script>
        </head>
        """ %( self.main_title, "%s") # note that to be used, an extra argument must be given (tmpdir)

    def print_form(self):
        print """
            <form method="post" action="%s" enctype="multipart/form-data">
            <strong>Please upload the file to evaluate  <br /></strong>The format must be ZIP or GZIP. The same validation scripts used <a href="http://wiki.c2b2.columbia.edu/dream/index.php/D5c2">in D5C2</a> are used.<p/>
            <input type="file" name="file"  size="60" /><p />
            <input type="hidden" name="dir" value="%s"  />
            <input type="submit" name="processing" value="submit" onclick="refresh_frame('myframe')" />
            </form>""" % (pj(params['cgibin_path'], params['this_script']), self.tmpdir)
        #Enter the captcha here :<input type="text" size="15" name="captcha">

    def print_redirect(self):
        thislink = pj(params['url'], 'cgi-bin', self.tmpdir, "results", "final.html")
        print """<head><meta http-equiv="refresh" content="5;url=%s"></meta></head>""" % thislink

    def print_header(self, mode="norefresh", location=None):
        print """Content-type:text/html\r""" # note the double \n (compulsary)
        print "\n\n"
        print self.header % self.tmpdir
        #if mode=="refresh":
        #print """<body background="../pbm2.gif" onload="refresh_frame();">"""
        #else:
        print """<body background="../pbm2.gif">"""

    def print_first_page(self, status="status.html"):
        """Main page when ask for the data file to be uploaded"""
        self.print_header(mode="refresh")
        self.print_title()
        #self.captcha()
        self.print_form()
        self.print_info()
        self.print_iframe(status=status)
        self.print_end()

    def print_iframe(self, status="status.html") :
        print """<iframe scrolling="yes" id="myframe" src="%s/%s" width="80%%" height="%s"></iframe>""" % (self.tmpdir, status, params['iframe_height'])
 
    def print_info(self):
        print """<br/><hr><p>The processing takes about 5 minutes. When over, you will be redirected to the results page.</p>"""
        #     <input type="button" value="refresh" onclick="refresh_frame();" /><br>

    #def print_results(self, image_filename):
    #    print """<img src="%s" tag="Results should appear here" height="%s" width="%s"></img><br/>""" % (image_filename, params['img_height'], params['img_width'])
    #    print """a temporary static page is also available <a href="%s/results/final.html">here</a>""" % self.tmpdir
    #    self.print_iframe() 

    def final_page(self, image_filename):
        results_dir = "results"
        try:
            os.mkdir(pj(self.tmpdir, results_dir))
        except OSError,e: 
            pass # file exist, skip this step
        except Exception, e:
            raise MyException(e)
        f = open(pj(self.tmpdir, results_dir, "final.html"), "w+")
        f.write("""<html>
         <head>
         <title>%s</title>
         <meta http-equiv="refresh" content="30">
         </head>
        """ % self.main_title)

        #tmpdir contains a .. hence the additional 'dream'
        final_page_url = pj(params['url'], 'dream', self.tmpdir, results_dir)

        f.write("""<body background="../../../pbm2.gif">\n""")
        f.write(self.titles)
        f.write("""<p>Your results are saved in <a href=\"%s\">%s</a></p>""" % (final_page_url, self.tmpdir[2:]))
        f.write("""<img src="final.png" alt="Image not ready ? Please wait...a minute or two." height="%(img_height)s" width="%(img_width)s"></img><br/>""" % params)
        f.write("""<p style="background-color:orange">Be aware that this page may be erased without notification in 24 hours.</p>""")
        thislink = pj(params['url'], 'cgi-bin', params['this_script'])
        f.write("""<p>Another prediction ? Go back to the <a href="%s">D5C2</a> page.</p>""" % thislink)
        f.write(self.footer)
        f.close()


def processing(tmpdir, form):
    # build the new page
    HTMLPage = BuildHTMLPage(directory=tmpdir)
    HTMLPage.print_header(mode="refresh")
    HTMLPage.print_title()
   
    # Now the processing 
    proc = D5C2(tmpdir=tmpdir)
    
    try: 
        item = form["file"]
        item.file
    except Exception, e:
        MyException("something wrong with your data. Have you provided a valid filename ?")
    finally:
        t1 = time.time()
        try:
            HTMLPage.print_info()
            HTMLPage.print_iframe(status="status.html")
            print "</body></html>"
            proc.uploading(item)
            proc.validating()
            proc.split_data()
            proc.probe_data(ROnly=False)
            t2 = time.time()
            proc.log("Analysis over. It took %10.4s seconds. " % str(t2-t1))
            proc.close()
            print """<p>Redirecting please wait. If it does not work, click <a href="%s">here</a></p>""" % pj(tmpdir, "results", "final.html")
            HTMLPage.final_page(proc.image_filename)
            HTMLPage.print_redirect()
        except MyException, e:
            #print e
            pass
